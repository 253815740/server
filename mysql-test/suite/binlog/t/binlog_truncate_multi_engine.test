# ==== Purpose ====
#
# Test verifies truncation of multiple binary logs.
#
# ==== Implementation ====
#
# Steps:
#    0 - Create two tables in innodb and rocksdb engines,
#        Set max_binlog_size= 4096.
#
# In loop for A,B,C cases (below) do 1-5:
#    1 - execute FLUSH LOGS command to generate a new binary log.
#        Start a transaction inserting rows of sufficient sizes
#        so binary log gets rotated at commit.
#    2 - Using debug simulation make the server crash at a point where
#        the transaction is written to binary log *and* either of
#        A. neither of them commits
#        B. only one commits
#        C. both commit
#    3 - At the time of crash three binary logs will be there
#        master-bin.0000001, master-bin.000002 and master-bin.000003.
#    4 - Restart server with --tc-heuristic-recover=BINLOG_TRUNCATE
#    5 - Since the prepared DML in master-bin.000002 the binary log will be
#        truncated and master-bin.000003 will be removed.
#
# ==== References ====
#
# MDEV-21117: --tc-heuristic-recover=rollback is not replication safe


--source include/have_innodb.inc
--source include/have_rocksdb.inc
--source include/have_log_bin.inc
--source include/have_debug.inc
--source include/have_debug_sync.inc
--source include/have_binlog_format_row.inc

SET @old_max_binlog_size= @@GLOBAL.max_binlog_size;
SET GLOBAL max_binlog_size= 4096;
call mtr.add_suppression("Can't init tc log");
call mtr.add_suppression("Aborting");

CREATE TABLE t1 (a INT PRIMARY KEY, b MEDIUMTEXT) ENGINE=Innodb;
CREATE TABLE t2 (a INT PRIMARY KEY, b MEDIUMTEXT) ENGINE=rocksdb;

--echo # Case A: neither engine committed => rollback & binlog truncate
# Hold off engine commits after write to binlog and its rotation.
# The transaction is killed along with the server after that.
--let $debug_sync_action = "commit_after_release_LOCK_log SIGNAL con1_ready WAIT_FOR _never_to_arrive"
--let $restart_options = --tc-heuristic-recover=BINLOG_TRUNCATE
--source binlog_truncate_multi_engine.inc

--connection default
--let $test_outcome= *** Zero rows should be present in both tables; binlog is truncated.

--echo # Case B: one engine has committed its transaction branch
# Hold off after one engine has committed.
--let $debug_sync_action = "commit_after_run_commit_ordered SIGNAL con1_ready WAIT_FOR _never_to_arrive"
--let $restart_options = --tc-heuristic-recover=BINLOG_TRUNCATE,--debug-dbug=d,binlog_truncate_partial_commit
--let $test_outcome= *** 1 row should be present in both tables; no binlog truncation.
--source binlog_truncate_multi_engine.inc

--echo # Case C: both engines have committed its transaction branch
# Hold off after both engines have committed.
--let $debug_sync_action = "commit_one_phase_2_ends SIGNAL con1_ready WAIT_FOR _never_to_arrive"
--let $restart_options = --tc-heuristic-recover=BINLOG_TRUNCATE
--let $test_outcome= 1 row should be present in both tables; no binlog truncation.
--source binlog_truncate_multi_engine.inc


--echo # Cleanup
DROP TABLE t1, t2;
SELECT @@GLOBAL.gtid_binlog_state;

--echo # End of the tests
